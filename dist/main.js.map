{"version":3,"sources":["webpack://forza-telemetry/./node_modules/electron-cgi/connection-builder.js","webpack://forza-telemetry/./node_modules/electron-cgi/connection.js","webpack://forza-telemetry/./node_modules/electron-cgi/index.js","webpack://forza-telemetry/./node_modules/electron-cgi/request.js","webpack://forza-telemetry/./node_modules/electron-cgi/tab-separated-input-stream-parser.js","webpack://forza-telemetry/./node_modules/uuid/lib/bytesToUuid.js","webpack://forza-telemetry/./node_modules/uuid/lib/rng.js","webpack://forza-telemetry/./node_modules/uuid/v4.js","webpack://forza-telemetry/external \"child_process\"","webpack://forza-telemetry/external \"crypto\"","webpack://forza-telemetry/external \"electron\"","webpack://forza-telemetry/external \"events\"","webpack://forza-telemetry/external \"path\"","webpack://forza-telemetry/external \"url\"","webpack://forza-telemetry/webpack/bootstrap","webpack://forza-telemetry/webpack/runtime/compat get default export","webpack://forza-telemetry/webpack/runtime/define property getters","webpack://forza-telemetry/webpack/runtime/hasOwnProperty shorthand","webpack://forza-telemetry/webpack/runtime/make namespace object","webpack://forza-telemetry/./src/main.ts"],"names":["url","require","path","ConnectionBuilder","window","createWindow","BrowserWindow","width","height","backgroundColor","autoHideMenuBar","webPreferences","nodeIntegration","contextIsolation","loadURL","format","pathname","join","__dirname","protocol","slashes","on","app","process","platform","connection","connectTo","build","onDisconnect","console","log","data","dataObj","JSON","parse","webContents","send","Steer","ipcMain","event","arg","response"],"mappings":"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","file":"main.js","sourcesContent":["const { spawn } = require('child_process');\nconst { Connection } = require('./connection');\n\nexports.ConnectionBuilder = function ConnectionBuilder() {\n    var spawnArguments = null;\n    this.connectTo = (command, ...args) => {\n        spawnArguments = {\n            command,\n            args\n        };\n        return this;\n    };\n    this.build = () => {\n        if (!spawnArguments) {\n            throw new Error('Use connectTo(pathToExecutable, [arguments]) to specify to which executable to connect');\n        }\n        const executable = spawn(spawnArguments.command, spawnArguments.args);\n \n        if (!executable.pid)\n            throw new Error(`Could not start ${spawnArguments.command}. Are you sure you have the right path?`);\n \n        executable.on('exit', (code) => {\n            if(this.handleOnExit){\n                this.handleOnExit(code);\n            }\n            console.log(`Connection to ${spawnArguments.command} was terminated (code: ${code})`)\n        });\n        executable.stderr.on('data', data => {\n            if(this.handleOnStderr)\n            {\n                this.handleOnStderr(data);\n            }\n            process.stdout.write('\\x1b[7m'); //invert terminal colors\n            process.stdout.write(data);\n            process.stdout.write('\\x1b[0m'); //reset colors\n        });\n        return new Connection(executable.stdin, executable.stdout);\n    };\n        \n    this.handleOnStderr = null;\n    this.handleOnExit = null;\n    this.onStderr = function(handler) {\n        this.handleOnStderr = handler\n        return this;\n    }\n    this.onExit = function (handler) {\n        this.handleOnExit = handler;\n        return this;\n    }         \n}\n","const Request = require('./request');\nconst TabSeparatedInputStreamParser = require('./tab-separated-input-stream-parser');\n\n/** @param {import('stream').Writable} outStream */\nexports.Connection = function Connection(outStream, inStream) {\n    const responseHandlersQueue = [];\n    const requestHandlersQueue = [];\n\n    const inputStreamParser = new TabSeparatedInputStreamParser();\n\n    inStream.setEncoding('utf8');\n    inStream.on('data', (chunk) => {\n        inputStreamParser.addPartial(chunk);\n    });\n\n    inStream.on('close', () => {\n        if (this.onDisconnect) {\n            this.onDisconnect();\n        }\n    });\n\n    inputStreamParser.onResponse(response => {\n        const responseIds = responseHandlersQueue.map(r => r.id);\n        if (responseIds.indexOf(response.id) !== -1) {\n            responseHandlersQueue.splice(responseIds.indexOf(response.id), 1)[0].onResponse(null, response.result);\n        }\n    });\n\n    inputStreamParser.onError(errorResponse => {\n        const responseIds = responseHandlersQueue.map(r => r.id);\n        if (responseIds.indexOf(errorResponse.requestId) !== -1) {\n            responseHandlersQueue.splice(responseIds.indexOf(errorResponse.requestId), 1)[0].onResponse(JSON.parse(errorResponse.error));\n        }\n    })\n\n    inputStreamParser.onRequest(request => {\n        const requestType = request.type;\n        requestHandlersQueue.filter(rh => rh.type === requestType).forEach(handlerContainer => {\n            const requestHandler = handlerContainer.onRequest;\n            const resultArgs = requestHandler(request.args)\n            sendResponse(request.id, resultArgs);\n        });\n    });\n\n    const sendResponse = (requestId, resultArgs) => {\n        if (!outStream.writable) return; //stream was closed    \n        outStream.write(`{\"type\": \"RESPONSE\", \"response\": ${JSON.stringify({\n            id: requestId,\n            result: JSON.stringify(resultArgs === undefined ? null : resultArgs)\n        })}}\\t`);\n    }\n\n    const sendRequest = (request, onResponse) => {\n        if (!outStream.writable) return;\n        outStream.write(`{\"type\": \"REQUEST\", \"request\": ${JSON.stringify(request)}}\\t`);\n        if (onResponse) {\n            responseHandlersQueue.push({\n                id: request.id,\n                onResponse\n            });\n        }\n    };\n\n    this.onDisconnect = null;\n\n    this.send = (type, args = {}, onResponse = null) => {\n        if (typeof args === 'function' && onResponse === null) { //if there's only one argument and it's a function assume it's the callback\n            onResponse = args;\n            args = {}\n        }\n        if (onResponse === null) {\n            return new Promise((resolve, reject) => {\n                sendRequest(new Request(type, args), (err, result) => {\n                    if (err)\n                        reject(err)\n                    else\n                        resolve(result)\n                });\n            });\n        } else {\n            sendRequest(new Request(type, args), onResponse);\n        }\n    };\n\n    this.on = (type, onRequest) => {\n        requestHandlersQueue.push({ type, onRequest })\n    }\n\n    this.close = () => {\n        outStream.end();\n    };\n}\n","const { ConnectionBuilder } = require(\"./connection-builder\");\n\nmodule.exports = {\n    ConnectionBuilder\n};","const uuidv4 = require('uuid/v4');\n\nfunction Request(type, args) {\n    this.type = type;\n    this.id = uuidv4();\n    this.args = JSON.stringify(args);\n}\n\nmodule.exports = Request;","const { EventEmitter } = require('events');\n\nfunction TabSeparatedInputStreamParser() {\n    const messageEmitter = new EventEmitter();\n    let streamInput = '';\n\n    this.addPartial = streamContent => {        \n        streamInput += streamContent;\n        while (streamInput.indexOf('\\t') !== -1) {\n            const messageStr = streamInput.substring(0, streamInput.indexOf('\\t'));\n            streamInput = streamInput.substring(streamInput.indexOf('\\t') + 1);\n            let message = null;\n            try {\n                message = JSON.parse(messageStr);\n            } catch (e) {\n                throw new Error(`Invalid incoming JSON: ${messageStr}`);\n            }\n            if (message.type === 'RESPONSE') {\n                messageEmitter.emit('response',message.response);\n            }else if (message.type === 'REQUEST') {\n                messageEmitter.emit('request', message.request);\n            }else if (message.type === 'ERROR'){\n                messageEmitter.emit('error', message)\n            }\n        }\n    };\n\n    this.onResponse = handleResponseCallback => {\n        messageEmitter.on('response', handleResponseCallback);\n    };\n\n    this.onError = handleErrorCallback => {\n        messageEmitter.on('error', handleErrorCallback);\n    };\n\n\n    this.onRequest = handleRequestCallback => {\n        messageEmitter.on('request', handleRequestCallback);\n    };\n}\n\nmodule.exports = TabSeparatedInputStreamParser;","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"path\");","module.exports = require(\"url\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const url = require(\"url\");\r\nconst path = require(\"path\");\r\nconst { ConnectionBuilder } = require(\"electron-cgi\");\r\n\r\nimport { app, BrowserWindow, ipcMain } from \"electron\";\r\n\r\nlet window: BrowserWindow | null;\r\n\r\nconst createWindow = () => {\r\n  window = new BrowserWindow({\r\n    width: 1920, \r\n    height: 1080,\r\n    backgroundColor: \"#1e1e1e\",\r\n    autoHideMenuBar: true,\r\n    webPreferences:{\r\n      nodeIntegration: true, // these two preferences are critical\r\n      contextIsolation: false // to getting data from main to dashboard\r\n    }\r\n  });\r\n\r\n  window.loadURL(\r\n    url.format({\r\n      pathname: path.join(__dirname, \"index.html\"),\r\n      protocol: \"file:\",\r\n      slashes: true\r\n    })\r\n  );\r\n\r\n  window.on(\"closed\", () => {\r\n    window = null;\r\n  });\r\n};\r\n\r\napp.on(\"ready\", createWindow);\r\n\r\napp.on(\"window-all-closed\", () => {\r\n  if (process.platform !== \"darwin\") {\r\n    app.quit();\r\n  }\r\n});\r\n\r\napp.on(\"activate\", () => {\r\n  if (window === null) {\r\n    createWindow();\r\n  }\r\n});\r\n\r\n// C# communication stuff ForzaDataDotNet\r\nconst connection = new ConnectionBuilder()\r\n  .connectTo('dotnet', 'run', '--project', 'ForzaCore')\r\n  .build();\r\n\r\nconnection.onDisconnect = () => {\r\n  console.log(\"lost\");\r\n};\r\n\r\n// receive\r\nconnection.on('new-data', (data: any) => {\r\n  // parse data into object\r\n  var dataObj = JSON.parse(data);\r\n  // send the data from forza to the front-end\r\n  window.webContents.send(\"new-data-for-dashboard\", dataObj);\r\n  // log this event\r\n  console.log(`${dataObj.Steer}`);\r\n});\r\n\r\nconnection.on('switch-recording-mode', (data: any) => {\r\n  // parse data into object\r\n  var dataObj = JSON.parse(data);\r\n  // send the data from forza to the front-end\r\n  window.webContents.send(\"new-data-for-dashboard\", dataObj);\r\n  // log this event\r\n  console.log(`${dataObj.Steer}`);\r\n});\r\n\r\n// send\r\nipcMain.on('switch-recording-mode', (event, arg) => {\r\n  connection.send(\"switch-recording-mode\", \"\", (response: any) => { });\r\n});"],"sourceRoot":""}